<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ele Ztian&#39;s Blog</title>
  
  <subtitle>Essay</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.eleztian.xyz/"/>
  <updated>2017-10-03T03:51:06.071Z</updated>
  <id>http://www.eleztian.xyz/</id>
  
  <author>
    <name>Ele Ztian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 信号机制</title>
    <link href="http://www.eleztian.xyz/2017/10/03/Linux-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.eleztian.xyz/2017/10/03/Linux-信号机制/</id>
    <published>2017-10-03T03:32:40.000Z</published>
    <updated>2017-10-03T03:51:06.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>Linux中的信号（signal)也叫 <strong>“软中断信号”</strong>，用于通知进程发生的异步事件。</li><li>早期信号的处理方法：<ol><li>指定处理函数，通过改函数中断处理 eg. signal(SIGALARM, handler)；</li><li>忽略该信号 eg. signal(SIGALARM, SIG_IGN；</li><li>对该信号的处理保留系统默认（缺省操作），eg. signal(SIGALARM, SIG_DFL),  大部分信号的缺省操作是终止进程；</li></ol></li><li>多信号处理<ol><li>SIG_x 打断 SIG_y的处理函数：</li><li>SIG_x 打断 SIG_x的处理函数：<br> a. 递归，调用同一个处理函数；<br> b. 忽略第二个信号；<br> c. 阻塞第二个信号直到第一个信号处理完毕；</li></ol></li><li>早期信号处理机制的问题<ol><li>捕鼠器问题（不可靠的信号）：<br> 一个信号表示一个具有破坏性的事情发生并被捕获，当信号或老鼠被捕后，捕鼠器失效，需要重置捕鼠器后才可以继续工作。然而重置捕鼠器是需要一定时间的及时时间很短，这个助理间隙就使得信号处理变得不可靠。</li><li>不知道信号被发送的原因：<br> 早期模型只是只是告诉处理器，处理函数被调用有什么信号引起，而没有说明产生这个信号的原因。</li><li>处理函数中不能安全的阻塞其他消息：</li></ol></li></ul><blockquote><p>在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。</p></blockquote><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><ul><li>signal.h</li></ul><ol><li><p>int signal(int signum, void (*action)(int));</p><pre><code>signum: 信号action: 如何响应 （SIG_IGN, SIG_DFL, 函数名（int signum））返回 -1 失败</code></pre></li><li><p>int sigaction(int signum, const struct sigaction <em>action,struct sigaction </em>prevation)；</p></li></ol><hr><p>man 手册查询 man 2 sigaction<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></div><div class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</div><div class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</div><div class="line">    <span class="keyword">sigset_t</span>   sa_mask;</div><div class="line">    <span class="keyword">int</span>        sa_flags;</div><div class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中 sa_handle 和 sa_sigaction 只能有一个。<br>sa_sigaction 相比较于sa_handle 可以获取更多的信息通过struct siginfo_t传递，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">siginfo_t</span> &#123;</span></div><div class="line">          <span class="keyword">int</span>      si_signo;    <span class="comment">/* Signal number */</span></div><div class="line">          <span class="keyword">int</span>      si_errno;    <span class="comment">/* An errno value */</span></div><div class="line">          <span class="keyword">int</span>      si_code;     <span class="comment">/* Signal code */</span></div><div class="line">          <span class="keyword">int</span>      si_trapno;   <span class="comment">/* Trap number that caused</span></div><div class="line"><span class="comment">                                   hardware-generated signal</span></div><div class="line"><span class="comment">                                   (unused on most architectures) */</span></div><div class="line">          <span class="keyword">pid_t</span>    si_pid;      <span class="comment">/* Sending process ID */</span></div><div class="line">          <span class="keyword">uid_t</span>    si_uid;      <span class="comment">/* Real user ID of sending process */</span></div><div class="line">          <span class="keyword">int</span>      si_status;   <span class="comment">/* Exit value or signal */</span></div><div class="line">          <span class="keyword">clock_t</span>  si_utime;    <span class="comment">/* User time consumed */</span></div><div class="line">          <span class="keyword">clock_t</span>  si_stime;    <span class="comment">/* System time consumed */</span></div><div class="line">          <span class="keyword">sigval_t</span> si_value;    <span class="comment">/* Signal value */</span></div><div class="line">          <span class="keyword">int</span>      si_int;      <span class="comment">/* POSIX.1b signal */</span></div><div class="line">          <span class="keyword">void</span>    *si_ptr;      <span class="comment">/* POSIX.1b signal */</span></div><div class="line">          <span class="keyword">int</span>      si_overrun;  <span class="comment">/* Timer overrun count; POSIX.1b timers */</span></div><div class="line">          <span class="keyword">int</span>      si_timerid;  <span class="comment">/* Timer ID; POSIX.1b timers */</span></div><div class="line">          <span class="keyword">void</span>    *si_addr;     <span class="comment">/* Memory location which caused fault */</span></div><div class="line">          <span class="keyword">int</span>      si_band;     <span class="comment">/* Band event */</span></div><div class="line">          <span class="keyword">int</span>      si_fd;       <span class="comment">/* File descriptor */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>sa_mask: 允许设置信号处理函数执行时所需要阻塞的信号。<br>sa_flags: 修改信号处理函数执行时的默认行为。</p><blockquote><p>sa_flags specifies a set of flags which modify the behavior of the signal.  It isformed by the bitwise OR of zero or more of the following:</p></blockquote><pre><code>SA_NOCLDSTOP       If signum is SIGCHLD, do not receive notification when child processes       stop  (i.e.,  when  they  receive  one of SIGSTOP, SIGTSTP, SIGTTIN or       SIGTTOU) or resume (i.e., they receive SIGCONT) (see  wait(2)).   This       flag is only meaningful when establishing a handler for SIGCHLD.SA_NOCLDWAIT (Since Linux 2.6)       If signum is SIGCHLD, do not transform children into zombies when they       terminate.  See also waitpid(2).  This flag is  only  meaningful  when       establishing a handler for SIGCHLD, or when setting that signal’s dis-       position to SIG_DFL.       If the SA_NOCLDWAIT flag  is  set  when  establishing  a  handler  for       SIGCHLD,  POSIX.1  leaves  it  unspecified whether a SIGCHLD signal is       generated when a child process terminates.  On Linux, a SIGCHLD signal       is generated in this case; on some other implementations, it is not.SA_NODEFER       Do not prevent the signal from being received from within its own sig-       nal handler.  This flag is only meaningful when establishing a  signal       handler.   SA_NOMASK  is  an  obsolete,  non-standard synonym for this       flag.SA_ONSTACK       Call the signal handler on  an  alternate  signal  stack  provided  by       sigaltstack(2).   If  an alternate stack is not available, the default       stack will be used.  This flag is only meaningful when establishing  a       signal handler.SA_RESETHAND       Restore the signal action to the default state once the signal handler       has been called.  This flag is only  meaningful  when  establishing  a       signal  handler.   SA_ONESHOT is an obsolete, non-standard synonym for       this flag.SA_RESTART       Provide behavior compatible with BSD signal semantics by  making  cer-       tain system calls restartable across signals.  This flag is only mean-       ingful when establishing a signal handler.  See signal(7) for  a  dis-       cussion of system call restarting.SA_SIGINFO (since Linux 2.2)       The  signal  handler  takes  3  arguments,  not  one.   In  this case,       sa_sigaction should be set instead of sa_handler.  This flag  is  only       meaningful when establishing a signal handler.</code></pre><h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><ol><li>由于信号处理函数是异步执行的，那么我们就无法预知它的执行时间，因此就存在数据共享问题：<br> a. 编译器优化导致处理函数中对变量的修改无法让主函数感知到：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> exit_flag = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hdl</span> <span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    exit_flag = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></div><div class="line"></div><div class="line">    <span class="built_in">memset</span> (&amp;act, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(act));</div><div class="line">    act.sa_handler = &amp;hdl;</div><div class="line">    <span class="keyword">if</span> (sigaction(SIGTERM, &amp;act, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        perror (<span class="string">"sigaction"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!exit_flag)</div><div class="line">        ;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>对上面的代码进行gcc O2级别优化，程序可以正常退出，但是如果采用O3级别优化，那么程序将不能退出。<br>    因为O2级别的优化时，编译器发现在程序中存在循环读取某一变量时，编译器为了提高效率为将这个变量直接装入寄存器，那么他读取数据时就是直接从寄存器读取而并不是从内存中，这就导致当信号处理函数修改这个变量后，主程序无法感知。解决办法是对变量夹volatile关键字，使其每次都从内存中读取数据。</p><p>其他问题后面遇见了再完善。</p><h1 id="特殊信号处理"><a href="#特殊信号处理" class="headerlink" title="特殊信号处理"></a>特殊信号处理</h1><blockquote><p>SIGCHLD信号</p></blockquote><p>一般我们不使用这个信号，它的存在作用主要在于清理僵尸进程。<br><strong><em>僵尸进程： 我们知道进程在执行exit()时是释放打开的文件等资源，但在linux中这个进程信息仍在存在进程表中没有被清除，这就是僵尸进程。我们知道进程ID等资源是有限的当僵尸进程过多就会导致无法创建新进程。</em></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigchld_handle</span> <span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">/* 等待所有已经退出的子进程。</span></div><div class="line"><span class="comment">     * 这里使用非阻塞的调用以防止子进程在代码其他地方被清理。 */</span></div><div class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>SIGBUS信号</p></blockquote><p>SIGBUS信号通常是访问被映射的内存时，无法映射到对应文件。<strong><em>映射（mmap(2)): 内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;–&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</em></strong><br>在这时进程缺省是直接退出，但是我们也是可以对其进行处理的。可以使用sigsetjmp(3)和siglohgjmp(3)跳转到错误的地方，让成宿继续执行。</p><pre><code>DESCRIPTION   setjmp()  and  longjmp(3) are useful for dealing with errors and inter-   rupts encountered in a low-level subroutine  of  a  program.   setjmp()   saves the stack context/environment in env for later use by longjmp(3).   The stack context will be invalidated  if  the  function  which  called   setjmp() returns.   sigsetjmp()  is similar to setjmp().  If, and only if, savesigs is non-   zero, the process’s current signal mask is saved in  env  and  will  be   restored if a siglongjmp(3) is later performed with this env.</code></pre><p>但是使用它们的时候一定要小心死锁的产生（我并不会用。。。）</p><blockquote><p>SIGSEGV信号</p></blockquote><p>SIGSEGV 段错误信号（这个倒是常见）, 谁然可以处理但是意义不大。 一种使用场景是在因为写保护而发生SIGEGV时可以通过siginfo_t 得到产出错误的原因从而使用mprotect(2)去除写保护。（没用过）<br>还有一种是，由于栈空间不足产生，可以使用sigaltstack(2)函数定义独立的栈空间。</p><blockquote><p>SIGABRT信号</p></blockquote><p><strong><em>abort(3)函数:用于终止一个进程。该函数先发送SIGABRT信号，如果该信号被忽略或该信号的处理函数正常返回，它会将信号处理函数重置为默认方式，并重发SIGABRT信号，使进程退出。</em></strong><br>因此处理SIGABRT信号可以在进程结束前做一些事情。<br>产生SIGABRT的一般原因：</p><ol><li>对野指针操作；</li><li>对一个地址free()多次；</li><li>assert失败；</li><li>堆越界</li></ol><h1 id="信号的使用"><a href="#信号的使用" class="headerlink" title="信号的使用"></a>信号的使用</h1><ol><li>Fork(), Fork()复制一个子进程，这个复制并不会复制父进程的信号队列，子进程会单独创建一个空信号队列。但是子进程会继承父进程所有的信号处理函数和信号阻塞状态。如果父进程以及完成了对信号的设置那么子进程无需再次设置。</li><li>pthread线程，一个进程下的所有线程有相同的进程ID（PID），向多线程发送信号的情况：<br> a. 向进程发送信号：<br> b. 向特定线程发送信号：</li><li><p>信号发送</p><ol><li>键盘交互（C+C(SIGINT), C+(SIGQUIT), C+Z(SIGSTOP)）</li><li>kill(pid_t pid, int sig),其中pid:<ul><li>0:目标为当前进程组的所有进程;</li><li>-1： 目标是所有的（可以发送信号）进程;</li><li>&lt;-1: 目标是进程ID为-ID的进程组；</li></ul></li><li>向进程自身发送信号：raise(3), abort（3）：<ul><li>raise(int sig):可以向进程发送指定信号（在多线程中只能想当前线程发送信号）</li><li>abort(): 发送SIFABRT信号——&gt;重置该信号-&gt;发送SIGABRT信号-&gt;程序终止</li></ul></li><li>sigqueue(pid_t pid, int sig, const union sigval value)，与kill类似，多了一个参数可以负载信息，通过siginfo_t获取这个参数。</li></ol></li><li><p>信号阻塞<br>阻塞信号，加入信号队列。可以防止当前程序被打断，防止信号竞争。实现方式：</p><ul><li>signal(int signum, sighandler_t handler), 将handler设置为SIG_IGN实现阻塞，该方式已经废弃。</li><li>sigprocmask(2), 它提供了更多的参数。如下例：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> got_signal = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hdl</span> <span class="params">(<span class="keyword">int</span> sig)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    got_signal = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">sigset_t</span> mask;</div><div class="line">    <span class="keyword">sigset_t</span> orig_mask;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></div><div class="line"></div><div class="line">    <span class="built_in">memset</span> (&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</div><div class="line">    act.sa_handler = hdl;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sigaction(SIGTERM, &amp;act, <span class="number">0</span>)) &#123;</div><div class="line">        perror (<span class="string">"sigaction"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sigemptyset (&amp;mask);</div><div class="line">    sigaddset (&amp;mask, SIGTERM);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, &amp;orig_mask) &lt; <span class="number">0</span>) &#123;</div><div class="line">        perror (<span class="string">"sigprocmask"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sleep (<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;orig_mask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        perror (<span class="string">"sigprocmask"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sleep (<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (got_signal)</div><div class="line">        <span class="built_in">puts</span> (<span class="string">"Got signal"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Linux中的信号（signal)也叫 &lt;strong&gt;“软中断信号”&lt;/strong&gt;，用于通知进程发生的异步事件。&lt;/li&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.eleztian.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.eleztian.xyz/tags/Linux/"/>
    
      <category term="c" scheme="http://www.eleztian.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>文件 IO</title>
    <link href="http://www.eleztian.xyz/2017/10/03/%E6%96%87%E4%BB%B6-IO/"/>
    <id>http://www.eleztian.xyz/2017/10/03/文件-IO/</id>
    <published>2017-10-03T03:31:04.000Z</published>
    <updated>2017-10-03T03:51:20.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文件描述符</p></blockquote><p>类型：一个非负正整数<br>范围：0 ~ OPEN_MAX - 1</p><ul><li>OPEN_MAX 现在已经被取消</li><li>ulimit -a 查看系统最大打开文件数</li><li>ulimit -n 最大数目  修改最大打开文件数</li></ul><p>常用惯例：</p><ul><li>0 -&gt; 标准输入   (STDIN_FILENO)</li><li>1 -&gt; 标准输出   (STDOUT_FILENO)</li><li>2 -&gt; 标准错误   (STDERR_FILENO)</li></ul><blockquote><p>int open(const char<em> filepath, int oflag, …)<br>  int openat(int fd, const char </em>filepath, int oflag, … )</p></blockquote><p>返回的fd一定是未使用的文件描述符中最小的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">OFLAG:</div><div class="line">    <span class="comment">/* 有且仅有一个 */</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_RDONLY    0       <span class="comment">/* +1 == FREAD */</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_WRONLY    1       <span class="comment">/* +1 == FWRITE */</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_RDWR      2       <span class="comment">/* +1 == FREAD|FWRITE */</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_EXEC          _FEXECSRCH</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_SEARCH        _FEXECSRCH</span></div><div class="line">    </div><div class="line">    <span class="comment">/* 可选 */</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_APPEND    _FAPPEND</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_CREAT     _FCREAT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_TRUNC     _FTRUNC <span class="comment">/* 若文件存在，长度截为0 */</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_EXCL      _FEXCL</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_SYNC      _FSYNC</span></div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_NONBLOCK  _FNONBLOCK</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_NOCTTY    _FNOCTTY</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_BINARY    _FBINARY</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_TEXT      _FTEXT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_CLOEXEC   _FNOINHERIT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_DIRECT        _FDIRECT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_NOFOLLOW      _FNOFOLLOW</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_DSYNC         _FSYNC</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_RSYNC         _FSYNC</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> O_DIRECTORY     _FDIRECTORY</span></div><div class="line">   </div><div class="line">     <span class="comment">/* O_NDELAY    _FNDELAY    set in include/fcntl.h */</span></div><div class="line">    <span class="comment">/*  O_NDELAY    _FNBIO      set in include/fcntl.h */</span></div></pre></td></tr></table></figure><p>openat 中的fd</p><ol><li>filepath 是绝对路径， 忽略fd.</li><li>filepath 是相对路径， fd是相对路径名在文件系统中的开始地址。通过打开目录来获取filepath</li><li>filepath 是相对路径， fd为AT_FDCWD，路径名在当前工作目录中获取。</li></ol><blockquote><p>int create(const char *filepath, mode_t mode)</p></blockquote><p>等效于 open(filepath, O_WRONLY|O_CREAT|0_TRUNC, mode);</p><blockquote><p>int close(int fd)   include<unistd.h></unistd.h></p></blockquote><p>在一个进程结束时，内核自动关闭这个进程打开的所有文件。</p><blockquote><p>off_t lseek(int fd, off_t offset, int whence)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">OFFSET:</div><div class="line">    <span class="meta"># <span class="meta-keyword">define</span>    SEEK_SET    0   <span class="comment">/* 距开始 */</span></span></div><div class="line">    <span class="meta"># <span class="meta-keyword">define</span>    SEEK_CUR    1   <span class="comment">/* 距当前 */</span></span></div><div class="line">    <span class="meta"># <span class="meta-keyword">define</span>    SEEK_END    2   <span class="comment">/* 距末尾 */</span></span></div></pre></td></tr></table></figure><p><strong><em> 如果 fd 是管道、FIFO、socket lseek返回-1， 置errorno 为ESPIPE。偏移量有可能为负， 因此在检测lseek是否正确时应该使用 ==-1 来判断而不能使用 &lt;0来判断*</em></strong><br>当lseek超过文件长度时， 对该文件的下一次写将加长该文件，并在文件中构成一个空洞。空洞都被置为0.空洞不要求在磁盘上占用空间（不分配磁盘块）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文件描述符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类型：一个非负正整数&lt;br&gt;范围：0 ~ OPEN_MAX - 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OPEN_MAX 现在已经被取消&lt;/li&gt;
&lt;li&gt;ulimit -a 查看系统最大打开文件数&lt;/l
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.eleztian.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.eleztian.xyz/tags/Linux/"/>
    
      <category term="c" scheme="http://www.eleztian.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程间通信</title>
    <link href="http://www.eleztian.xyz/2017/10/03/Linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.eleztian.xyz/2017/10/03/Linux-进程间通信/</id>
    <published>2017-10-03T03:27:36.000Z</published>
    <updated>2017-10-03T03:50:23.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>进程间通信方式</p></blockquote><ol><li>管道(pipe)</li><li>系统IPC(消息队列、信号量、共享存储）</li><li>socket</li></ol><blockquote><p>管道</p></blockquote><ol><li>普通管道：半双工通信方式，数据单向流动且只能在具有亲缘关系（父子进程关系）的进程间使用。</li><li>流管道：与普通管道不同的是，它允许双向传送</li><li>有名管道：与普通管道不同的是它允许在无亲缘关系的进程间使用。</li></ol><blockquote><p>系统IPC</p></blockquote><ol><li>共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程所创建，但是多个进程都能访问。<br> <strong><em>共享内存是最快的IPC方式</em></strong>，是针对进程间通信效率低而设计的。往往与其往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li>消息对列：消息队列是由消息链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 </li></ol><blockquote><p>SOCKET</p></blockquote><p>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><blockquote><p>各种通信方式的比较和优缺点</p></blockquote><p>管道：速度慢，容量有限，只有父子进程能通讯<br>FIFO：任何进程间都能通讯，但速度慢<br>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题<br>信号量：不能传递复杂消息，只能用来同步<br>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;进程间通信方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;管道(pipe)&lt;/li&gt;
&lt;li&gt;系统IPC(消息队列、信号量、共享存储）&lt;/li&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;管道&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://www.eleztian.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.eleztian.xyz/tags/Linux/"/>
    
      <category term="c" scheme="http://www.eleztian.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统移植步骤</title>
    <link href="http://www.eleztian.xyz/2017/10/03/Linux-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E6%AD%A5%E9%AA%A4/"/>
    <id>http://www.eleztian.xyz/2017/10/03/Linux-系统移植步骤/</id>
    <published>2017-10-03T03:26:07.000Z</published>
    <updated>2017-10-03T03:50:43.561Z</updated>
    
    <content type="html"><![CDATA[<p>1) 准备工作，包括下载源码、建立交叉编译环境等。交叉开发是指在开发主机上安装开发工具，编辑、编译目标板的引导程序、内核和文件系统，使其能在目标板上运行。<br>2) 配置和编bootloader（引导装载程序）。通过这段小程序，可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统硬件环境，为最终调用操作系统内核做好准备。<br>3) 配置和编译Linux内核，对其进行相应的裁剪，修改内核以支持相关的硬件设备。<br>4) 为大容量NAND Flash移植YAFFS文件系统，并将该文件系统加入Linux内核中；<br>5) 制作RAMdisk来挂载根文件系统。Linux系统中的文件和设备是通过文件系统来组织的。文件系统的存在使得数据和设备可以被有效而透明地存取访问。一个linux的最简根文件系统应该包括支持linux系统正常运行的基本内容，包括系统使用的软件和库，以及所有用来为用户提供基本支持的架构和指令。<br>6) 烧写、调试系统；如果调试出错，则需要重新配置，返回上述步骤（2）。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1) 准备工作，包括下载源码、建立交叉编译环境等。交叉开发是指在开发主机上安装开发工具，编辑、编译目标板的引导程序、内核和文件系统，使其能在目标板上运行。&lt;br&gt;2) 配置和编bootloader（引导装载程序）。通过这段小程序，可以初始化硬件设备、建立内存空间的映射表，从
      
    
    </summary>
    
      <category term="嵌入式" scheme="http://www.eleztian.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="Linux" scheme="http://www.eleztian.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Fork and exec </title>
    <link href="http://www.eleztian.xyz/2017/10/03/Fork-and-exec/"/>
    <id>http://www.eleztian.xyz/2017/10/03/Fork-and-exec/</id>
    <published>2017-10-03T03:24:37.000Z</published>
    <updated>2017-10-03T03:49:50.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fork-与-exec-函数"><a href="#Fork-与-exec-函数" class="headerlink" title="Fork 与 exec 函数"></a>Fork 与 exec 函数</h1><h1 id="先得直到这些"><a href="#先得直到这些" class="headerlink" title="先得直到这些"></a>先得直到这些</h1><p>###进程标识###</p><ol><li>每个进程的进程标识PID（非负正整数）唯一的。</li><li>进程标识PID是可复用的，进程终结后ID成为复用候选者，但大多数Linux采用延迟复用算法，使得新建进程的ID不同于最近进程所使用的ID，防止误认为新进程与原进程是同一个进程。</li><li></li></ol><p>#Fork长这样#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pid_t fork(void);</div><div class="line">// 返回：在子进程中返回 0， 在父进程中返回子进程的PID， 出错返回-1</div></pre></td></tr></table></figure></p><p>#这样实现Fork返回值的原因#<br>    每一个子进程只有1个父进程，可以通过getppid()获取父进程PID，而一个进程可以有多个子进程且无法获取每个子进程的PID，父进程只能通过记录Fork返回值的方式跟踪子进程。</p><p>#fork()做了那些事儿#<br>Fork函数调用后会复制当前进程（调用clone()函数）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Fork 调用过程</div><div class="line">// fork()-&gt;clone()-&gt;do_fork()-&gt;copy_process()</div></pre></td></tr></table></figure></p><p>进行过程如下：</p><ol><li>创建一个与父进程<strong><em>相同</em></strong>的内核栈、数据空间（thread_info、task_struct）,此时父子进程的描述符相同</li><li>进程数量安全检测</li><li>区别父子进程描述符，处理部分描述符（清0或设置）</li><li>设置子进程状态为等待状态（可被信号解除）</li><li>其他一些设个性化置</li><li>为子进程分配有效PID</li><li>拷贝或共享打开的文件、进程地址空间等</li><li>返回子进程指针</li></ol><h2 id="父子进程间的不同"><a href="#父子进程间的不同" class="headerlink" title="父子进程间的不同"></a>父子进程间的不同</h2><ol><li>fork（）返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程不同</li><li>子进程的tms_xx设置为0</li><li>子进程不继承父进程的文件锁</li><li>子进程不处理的闹钟会被清除</li><li>子进程未处理的信号集会被设为空集(子进程会单独创建一个空信号队列，但是子进程会继承父进程所有的信号处理函数和信号阻塞状态)</li></ol><p><strong><em>虽然父子进程数据空间、堆栈基本相同,但是父子进程不共享这段存储空间。</em></strong></p><p>Fork之后通常调用exec()，因此现在很多实现不会执行一个父进程的完全副本，而是采用写时复用（COW）技术，这些区域父子进程共享，权限为只读，当某一个进程试图修改某一数据时，内核会给他创建一个副本（虚拟存储系统中的一页）。</p><p>#fork这样使用#</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pid_t pid;</div><div class="line">if((pid = fork()) &lt; 0)</div><div class="line">    //出错</div><div class="line">else if(pid == 0)</div><div class="line">    //子进程</div><div class="line">else</div><div class="line">    //父进程</div></pre></td></tr></table></figure><p>##fork有两个典型用法##</p><ol><li>一个进程复制自己（创建自身的一个副本），是父进程和子进程同时执行两段不同的代码，网络服务器的典型用法（父进程等待客户端的请求，当请求到达时，调用fork执行这个请求，父进程继续等待请求）。</li><li>一个进程需要执行不同的程序，fork（）之后其中一个进程立即调用exec()，shell中典型。</li></ol><h2 id="fork调用失败的原因"><a href="#fork调用失败的原因" class="headerlink" title="fork调用失败的原因"></a>fork调用失败的原因</h2><ol><li>系统中已经有太多的进程（有可能僵尸进程没有清楚，或其他有问题）。</li><li>实际用户ID的进程数超过限制。</li></ol><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ol><li>fork之后子进程和父进程谁先执行不能确定，这取决于内核的进程调度算法。</li><li>一般情况下fork之后父子进程都需要关闭他们不需要的描述符，防止相符干扰（网络服务器进程常用）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fork-与-exec-函数&quot;&gt;&lt;a href=&quot;#Fork-与-exec-函数&quot; class=&quot;headerlink&quot; title=&quot;Fork 与 exec 函数&quot;&gt;&lt;/a&gt;Fork 与 exec 函数&lt;/h1&gt;&lt;h1 id=&quot;先得直到这些&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.eleztian.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.eleztian.xyz/tags/Linux/"/>
    
      <category term="c" scheme="http://www.eleztian.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.eleztian.xyz/2017/10/01/hello-world/"/>
    <id>http://www.eleztian.xyz/2017/10/01/hello-world/</id>
    <published>2017-10-01T12:58:35.479Z</published>
    <updated>2017-10-03T03:51:47.073Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hello" scheme="http://www.eleztian.xyz/categories/Hello/"/>
    
    
      <category term="hello" scheme="http://www.eleztian.xyz/tags/hello/"/>
    
      <category term="test" scheme="http://www.eleztian.xyz/tags/test/"/>
    
  </entry>
  
</feed>
