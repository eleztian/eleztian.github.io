---
title: 'Fork and exec '
date: 2017-10-03 11:24:37
categories: "Linux"
tags: [Linux, c]
keyworlds: Linux, c
description:
---
# Fork 与 exec 函数


# 先得直到这些#
###进程标识###

1. 每个进程的进程标识PID（非负正整数）唯一的。
2. 进程标识PID是可复用的，进程终结后ID成为复用候选者，但大多数Linux采用延迟复用算法，使得新建进程的ID不同于最近进程所使用的ID，防止误认为新进程与原进程是同一个进程。
3. 

#Fork长这样#
```
pid_t fork(void);
// 返回：在子进程中返回 0， 在父进程中返回子进程的PID， 出错返回-1
```
#这样实现Fork返回值的原因#
    每一个子进程只有1个父进程，可以通过getppid()获取父进程PID，而一个进程可以有多个子进程且无法获取每个子进程的PID，父进程只能通过记录Fork返回值的方式跟踪子进程。

#fork()做了那些事儿#
Fork函数调用后会复制当前进程（调用clone()函数）
```
// Fork 调用过程
// fork()->clone()->do_fork()->copy_process()
```
进行过程如下：

1. 创建一个与父进程***相同***的内核栈、数据空间（thread_info、task_struct）,此时父子进程的描述符相同
2. 进程数量安全检测
3. 区别父子进程描述符，处理部分描述符（清0或设置）
4. 设置子进程状态为等待状态（可被信号解除）
5. 其他一些设个性化置
6. 为子进程分配有效PID
7. 拷贝或共享打开的文件、进程地址空间等
8. 返回子进程指针

## 父子进程间的不同 ##

1. fork（）返回值不同
2. 进程ID不同
3. 这两个进程的父进程不同
4. 子进程的tms_xx设置为0
5. 子进程不继承父进程的文件锁
6. 子进程不处理的闹钟会被清除
7. 子进程未处理的信号集会被设为空集(子进程会单独创建一个空信号队列，但是子进程会继承父进程所有的信号处理函数和信号阻塞状态)

***虽然父子进程数据空间、堆栈基本相同,但是父子进程不共享这段存储空间。***

Fork之后通常调用exec()，因此现在很多实现不会执行一个父进程的完全副本，而是采用写时复用（COW）技术，这些区域父子进程共享，权限为只读，当某一个进程试图修改某一数据时，内核会给他创建一个副本（虚拟存储系统中的一页）。

#fork这样使用#

```
pid_t pid;
if((pid = fork()) < 0)
    //出错
else if(pid == 0)
    //子进程
else
    //父进程
```
##fork有两个典型用法##

1. 一个进程复制自己（创建自身的一个副本），是父进程和子进程同时执行两段不同的代码，网络服务器的典型用法（父进程等待客户端的请求，当请求到达时，调用fork执行这个请求，父进程继续等待请求）。
2. 一个进程需要执行不同的程序，fork（）之后其中一个进程立即调用exec()，shell中典型。

## fork调用失败的原因 ##

1. 系统中已经有太多的进程（有可能僵尸进程没有清楚，或其他有问题）。
2. 实际用户ID的进程数超过限制。

## 使用注意事项 ##
1. fork之后子进程和父进程谁先执行不能确定，这取决于内核的进程调度算法。
2. 一般情况下fork之后父子进程都需要关闭他们不需要的描述符，防止相符干扰（网络服务器进程常用）。

