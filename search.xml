<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 信号机制]]></title>
    <url>%2F2017%2F10%2FLinux-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概念 Linux中的信号（signal)也叫 “软中断信号”，用于通知进程发生的异步事件。 早期信号的处理方法： 指定处理函数，通过改函数中断处理 eg. signal(SIGALARM, handler)； 忽略该信号 eg. signal(SIGALARM, SIG_IGN； 对该信号的处理保留系统默认（缺省操作），eg. signal(SIGALARM, SIG_DFL), 大部分信号的缺省操作是终止进程； 多信号处理 SIG_x 打断 SIG_y的处理函数： SIG_x 打断 SIG_x的处理函数： a. 递归，调用同一个处理函数； b. 忽略第二个信号； c. 阻塞第二个信号直到第一个信号处理完毕； 早期信号处理机制的问题 捕鼠器问题（不可靠的信号）： 一个信号表示一个具有破坏性的事情发生并被捕获，当信号或老鼠被捕后，捕鼠器失效，需要重置捕鼠器后才可以继续工作。然而重置捕鼠器是需要一定时间的及时时间很短，这个助理间隙就使得信号处理变得不可靠。 不知道信号被发送的原因： 早期模型只是只是告诉处理器，处理函数被调用有什么信号引起，而没有说明产生这个信号的原因。 处理函数中不能安全的阻塞其他消息： 在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。 编程 signal.h int signal(int signum, void (*action)(int)); signum: 信号 action: 如何响应 （SIG_IGN, SIG_DFL, 函数名（int signum）） 返回 -1 失败 int sigaction(int signum, const struct sigaction action,struct sigaction prevation)； man 手册查询 man 2 sigaction1234567struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);&#125;; 其中 sa_handle 和 sa_sigaction 只能有一个。sa_sigaction 相比较于sa_handle 可以获取更多的信息通过struct siginfo_t传递，如下：123456789101112131415161718192021 struct siginfo_t &#123; int si_signo; /* Signal number */ int si_errno; /* An errno value */ int si_code; /* Signal code */ int si_trapno; /* Trap number that caused hardware-generated signal (unused on most architectures) */ pid_t si_pid; /* Sending process ID */ uid_t si_uid; /* Real user ID of sending process */ int si_status; /* Exit value or signal */ clock_t si_utime; /* User time consumed */ clock_t si_stime; /* System time consumed */ sigval_t si_value; /* Signal value */ int si_int; /* POSIX.1b signal */ void *si_ptr; /* POSIX.1b signal */ int si_overrun; /* Timer overrun count; POSIX.1b timers */ int si_timerid; /* Timer ID; POSIX.1b timers */ void *si_addr; /* Memory location which caused fault */ int si_band; /* Band event */ int si_fd; /* File descriptor */&#125; sa_mask: 允许设置信号处理函数执行时所需要阻塞的信号。sa_flags: 修改信号处理函数执行时的默认行为。 sa_flags specifies a set of flags which modify the behavior of the signal. It isformed by the bitwise OR of zero or more of the following: SA_NOCLDSTOP If signum is SIGCHLD, do not receive notification when child processes stop (i.e., when they receive one of SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU) or resume (i.e., they receive SIGCONT) (see wait(2)). This flag is only meaningful when establishing a handler for SIGCHLD. SA_NOCLDWAIT (Since Linux 2.6) If signum is SIGCHLD, do not transform children into zombies when they terminate. See also waitpid(2). This flag is only meaningful when establishing a handler for SIGCHLD, or when setting that signal’s dis- position to SIG_DFL. If the SA_NOCLDWAIT flag is set when establishing a handler for SIGCHLD, POSIX.1 leaves it unspecified whether a SIGCHLD signal is generated when a child process terminates. On Linux, a SIGCHLD signal is generated in this case; on some other implementations, it is not. SA_NODEFER Do not prevent the signal from being received from within its own sig- nal handler. This flag is only meaningful when establishing a signal handler. SA_NOMASK is an obsolete, non-standard synonym for this flag. SA_ONSTACK Call the signal handler on an alternate signal stack provided by sigaltstack(2). If an alternate stack is not available, the default stack will be used. This flag is only meaningful when establishing a signal handler. SA_RESETHAND Restore the signal action to the default state once the signal handler has been called. This flag is only meaningful when establishing a signal handler. SA_ONESHOT is an obsolete, non-standard synonym for this flag. SA_RESTART Provide behavior compatible with BSD signal semantics by making cer- tain system calls restartable across signals. This flag is only mean- ingful when establishing a signal handler. See signal(7) for a dis- cussion of system call restarting. SA_SIGINFO (since Linux 2.2) The signal handler takes 3 arguments, not one. In this case, sa_sigaction should be set instead of sa_handler. This flag is only meaningful when establishing a signal handler. 常见问题： 由于信号处理函数是异步执行的，那么我们就无法预知它的执行时间，因此就存在数据共享问题： a. 编译器优化导致处理函数中对变量的修改无法让主函数感知到：12345678910111213141516171819202122232425262728 #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;static int exit_flag = 0;static void hdl (int sig)&#123; exit_flag = 1;&#125;int main (int argc, char *argv[])&#123; struct sigaction act; memset (&amp;act, '\0', sizeof(act)); act.sa_handler = &amp;hdl; if (sigaction(SIGTERM, &amp;act, NULL) &lt; 0) &#123; perror ("sigaction"); return 1; &#125; while (!exit_flag) ; return 0;&#125; 对上面的代码进行gcc O2级别优化，程序可以正常退出，但是如果采用O3级别优化，那么程序将不能退出。 因为O2级别的优化时，编译器发现在程序中存在循环读取某一变量时，编译器为了提高效率为将这个变量直接装入寄存器，那么他读取数据时就是直接从寄存器读取而并不是从内存中，这就导致当信号处理函数修改这个变量后，主程序无法感知。解决办法是对变量夹volatile关键字，使其每次都从内存中读取数据。 其他问题后面遇见了再完善。 特殊信号处理 SIGCHLD信号 一般我们不使用这个信号，它的存在作用主要在于清理僵尸进程。僵尸进程： 我们知道进程在执行exit()时是释放打开的文件等资源，但在linux中这个进程信息仍在存在进程表中没有被清除，这就是僵尸进程。我们知道进程ID等资源是有限的当僵尸进程过多就会导致无法创建新进程。1234567static void sigchld_handle (int sig)&#123; /* 等待所有已经退出的子进程。 * 这里使用非阻塞的调用以防止子进程在代码其他地方被清理。 */ while (waitpid(-1, NULL, WNOHANG) &gt; 0) &#123; &#125;&#125; SIGBUS信号 SIGBUS信号通常是访问被映射的内存时，无法映射到对应文件。映射（mmap(2)): 内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;–&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。在这时进程缺省是直接退出，但是我们也是可以对其进行处理的。可以使用sigsetjmp(3)和siglohgjmp(3)跳转到错误的地方，让成宿继续执行。 DESCRIPTION setjmp() and longjmp(3) are useful for dealing with errors and inter- rupts encountered in a low-level subroutine of a program. setjmp() saves the stack context/environment in env for later use by longjmp(3). The stack context will be invalidated if the function which called setjmp() returns. sigsetjmp() is similar to setjmp(). If, and only if, savesigs is non- zero, the process’s current signal mask is saved in env and will be restored if a siglongjmp(3) is later performed with this env. 但是使用它们的时候一定要小心死锁的产生（我并不会用。。。） SIGSEGV信号 SIGSEGV 段错误信号（这个倒是常见）, 谁然可以处理但是意义不大。 一种使用场景是在因为写保护而发生SIGEGV时可以通过siginfo_t 得到产出错误的原因从而使用mprotect(2)去除写保护。（没用过）还有一种是，由于栈空间不足产生，可以使用sigaltstack(2)函数定义独立的栈空间。 SIGABRT信号 abort(3)函数:用于终止一个进程。该函数先发送SIGABRT信号，如果该信号被忽略或该信号的处理函数正常返回，它会将信号处理函数重置为默认方式，并重发SIGABRT信号，使进程退出。因此处理SIGABRT信号可以在进程结束前做一些事情。产生SIGABRT的一般原因： 对野指针操作； 对一个地址free()多次； assert失败； 堆越界 信号的使用 Fork(), Fork()复制一个子进程，这个复制并不会复制父进程的信号队列，子进程会单独创建一个空信号队列。但是子进程会继承父进程所有的信号处理函数和信号阻塞状态。如果父进程以及完成了对信号的设置那么子进程无需再次设置。 pthread线程，一个进程下的所有线程有相同的进程ID（PID），向多线程发送信号的情况： a. 向进程发送信号： b. 向特定线程发送信号： 信号发送 键盘交互（C+C(SIGINT), C+(SIGQUIT), C+Z(SIGSTOP)） kill(pid_t pid, int sig),其中pid: 0:目标为当前进程组的所有进程; -1： 目标是所有的（可以发送信号）进程; &lt;-1: 目标是进程ID为-ID的进程组； 向进程自身发送信号：raise(3), abort（3）： raise(int sig):可以向进程发送指定信号（在多线程中只能想当前线程发送信号） abort(): 发送SIFABRT信号——&gt;重置该信号-&gt;发送SIGABRT信号-&gt;程序终止 sigqueue(pid_t pid, int sig, const union sigval value)，与kill类似，多了一个参数可以负载信息，通过siginfo_t获取这个参数。 信号阻塞阻塞信号，加入信号队列。可以防止当前程序被打断，防止信号竞争。实现方式： signal(int signum, sighandler_t handler), 将handler设置为SIG_IGN实现阻塞，该方式已经废弃。 sigprocmask(2), 它提供了更多的参数。如下例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;static int got_signal = 0;static void hdl (int sig)&#123; got_signal = 1;&#125;int main (int argc, char *argv[])&#123; sigset_t mask; sigset_t orig_mask; struct sigaction act; memset (&amp;act, 0, sizeof(act)); act.sa_handler = hdl; if (sigaction(SIGTERM, &amp;act, 0)) &#123; perror ("sigaction"); return 1; &#125; sigemptyset (&amp;mask); sigaddset (&amp;mask, SIGTERM); if (sigprocmask(SIG_BLOCK, &amp;mask, &amp;orig_mask) &lt; 0) &#123; perror ("sigprocmask"); return 1; &#125; sleep (10); if (sigprocmask(SIG_SETMASK, &amp;orig_mask, NULL) &lt; 0) &#123; perror ("sigprocmask"); return 1; &#125; sleep (1); if (got_signal) puts ("Got signal"); return 0;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件 IO]]></title>
    <url>%2F2017%2F10%2F%E6%96%87%E4%BB%B6-IO%2F</url>
    <content type="text"><![CDATA[文件描述符 类型：一个非负正整数范围：0 ~ OPEN_MAX - 1 OPEN_MAX 现在已经被取消 ulimit -a 查看系统最大打开文件数 ulimit -n 最大数目 修改最大打开文件数 常用惯例： 0 -&gt; 标准输入 (STDIN_FILENO) 1 -&gt; 标准输出 (STDOUT_FILENO) 2 -&gt; 标准错误 (STDERR_FILENO) int open(const char filepath, int oflag, …) int openat(int fd, const char filepath, int oflag, … ) 返回的fd一定是未使用的文件描述符中最小的 12345678910111213141516171819202122232425262728OFLAG: /* 有且仅有一个 */ #define O_RDONLY 0 /* +1 == FREAD */ #define O_WRONLY 1 /* +1 == FWRITE */ #define O_RDWR 2 /* +1 == FREAD|FWRITE */ #define O_EXEC _FEXECSRCH #define O_SEARCH _FEXECSRCH /* 可选 */ #define O_APPEND _FAPPEND #define O_CREAT _FCREAT #define O_TRUNC _FTRUNC /* 若文件存在，长度截为0 */ #define O_EXCL _FEXCL #define O_SYNC _FSYNC #define O_NONBLOCK _FNONBLOCK #define O_NOCTTY _FNOCTTY #define O_BINARY _FBINARY #define O_TEXT _FTEXT #define O_CLOEXEC _FNOINHERIT #define O_DIRECT _FDIRECT #define O_NOFOLLOW _FNOFOLLOW #define O_DSYNC _FSYNC #define O_RSYNC _FSYNC #define O_DIRECTORY _FDIRECTORY /* O_NDELAY _FNDELAY set in include/fcntl.h */ /* O_NDELAY _FNBIO set in include/fcntl.h */ openat 中的fd filepath 是绝对路径， 忽略fd. filepath 是相对路径， fd是相对路径名在文件系统中的开始地址。通过打开目录来获取filepath filepath 是相对路径， fd为AT_FDCWD，路径名在当前工作目录中获取。 int create(const char *filepath, mode_t mode) 等效于 open(filepath, O_WRONLY|O_CREAT|0_TRUNC, mode); int close(int fd) include 在一个进程结束时，内核自动关闭这个进程打开的所有文件。 off_t lseek(int fd, off_t offset, int whence) 1234OFFSET: # define SEEK_SET 0 /* 距开始 */ # define SEEK_CUR 1 /* 距当前 */ # define SEEK_END 2 /* 距末尾 */ 如果 fd 是管道、FIFO、socket lseek返回-1， 置errorno 为ESPIPE。偏移量有可能为负， 因此在检测lseek是否正确时应该使用 ==-1 来判断而不能使用 &lt;0来判断*当lseek超过文件长度时， 对该文件的下一次写将加长该文件，并在文件中构成一个空洞。空洞都被置为0.空洞不要求在磁盘上占用空间（不分配磁盘块）。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程间通信]]></title>
    <url>%2F2017%2F10%2FLinux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间通信方式 管道(pipe) 系统IPC(消息队列、信号量、共享存储） socket 管道 普通管道：半双工通信方式，数据单向流动且只能在具有亲缘关系（父子进程关系）的进程间使用。 流管道：与普通管道不同的是，它允许双向传送 有名管道：与普通管道不同的是它允许在无亲缘关系的进程间使用。 系统IPC 共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程所创建，但是多个进程都能访问。 共享内存是最快的IPC方式，是针对进程间通信效率低而设计的。往往与其往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 消息对列：消息队列是由消息链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 SOCKET 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信 各种通信方式的比较和优缺点 管道：速度慢，容量有限，只有父子进程能通讯FIFO：任何进程间都能通讯，但速度慢消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题信号量：不能传递复杂消息，只能用来同步共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统移植步骤]]></title>
    <url>%2F2017%2F10%2FLinux-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[1) 准备工作，包括下载源码、建立交叉编译环境等。交叉开发是指在开发主机上安装开发工具，编辑、编译目标板的引导程序、内核和文件系统，使其能在目标板上运行。2) 配置和编bootloader（引导装载程序）。通过这段小程序，可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统硬件环境，为最终调用操作系统内核做好准备。3) 配置和编译Linux内核，对其进行相应的裁剪，修改内核以支持相关的硬件设备。4) 为大容量NAND Flash移植YAFFS文件系统，并将该文件系统加入Linux内核中；5) 制作RAMdisk来挂载根文件系统。Linux系统中的文件和设备是通过文件系统来组织的。文件系统的存在使得数据和设备可以被有效而透明地存取访问。一个linux的最简根文件系统应该包括支持linux系统正常运行的基本内容，包括系统使用的软件和库，以及所有用来为用户提供基本支持的架构和指令。6) 烧写、调试系统；如果调试出错，则需要重新配置，返回上述步骤（2）。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fork and exec]]></title>
    <url>%2F2017%2F10%2FFork-and-exec%2F</url>
    <content type="text"><![CDATA[Fork 与 exec 函数先得直到这些###进程标识### 每个进程的进程标识PID（非负正整数）唯一的。 进程标识PID是可复用的，进程终结后ID成为复用候选者，但大多数Linux采用延迟复用算法，使得新建进程的ID不同于最近进程所使用的ID，防止误认为新进程与原进程是同一个进程。 #Fork长这样#12pid_t fork(void);// 返回：在子进程中返回 0， 在父进程中返回子进程的PID， 出错返回-1 #这样实现Fork返回值的原因# 每一个子进程只有1个父进程，可以通过getppid()获取父进程PID，而一个进程可以有多个子进程且无法获取每个子进程的PID，父进程只能通过记录Fork返回值的方式跟踪子进程。 #fork()做了那些事儿#Fork函数调用后会复制当前进程（调用clone()函数）12// Fork 调用过程// fork()-&gt;clone()-&gt;do_fork()-&gt;copy_process() 进行过程如下： 创建一个与父进程相同的内核栈、数据空间（thread_info、task_struct）,此时父子进程的描述符相同 进程数量安全检测 区别父子进程描述符，处理部分描述符（清0或设置） 设置子进程状态为等待状态（可被信号解除） 其他一些设个性化置 为子进程分配有效PID 拷贝或共享打开的文件、进程地址空间等 返回子进程指针 父子进程间的不同 fork（）返回值不同 进程ID不同 这两个进程的父进程不同 子进程的tms_xx设置为0 子进程不继承父进程的文件锁 子进程不处理的闹钟会被清除 子进程未处理的信号集会被设为空集(子进程会单独创建一个空信号队列，但是子进程会继承父进程所有的信号处理函数和信号阻塞状态) 虽然父子进程数据空间、堆栈基本相同,但是父子进程不共享这段存储空间。 Fork之后通常调用exec()，因此现在很多实现不会执行一个父进程的完全副本，而是采用写时复用（COW）技术，这些区域父子进程共享，权限为只读，当某一个进程试图修改某一数据时，内核会给他创建一个副本（虚拟存储系统中的一页）。 #fork这样使用# 1234567pid_t pid;if((pid = fork()) &lt; 0) //出错else if(pid == 0) //子进程else //父进程 ##fork有两个典型用法## 一个进程复制自己（创建自身的一个副本），是父进程和子进程同时执行两段不同的代码，网络服务器的典型用法（父进程等待客户端的请求，当请求到达时，调用fork执行这个请求，父进程继续等待请求）。 一个进程需要执行不同的程序，fork（）之后其中一个进程立即调用exec()，shell中典型。 fork调用失败的原因 系统中已经有太多的进程（有可能僵尸进程没有清楚，或其他有问题）。 实际用户ID的进程数超过限制。 使用注意事项 fork之后子进程和父进程谁先执行不能确定，这取决于内核的进程调度算法。 一般情况下fork之后父子进程都需要关闭他们不需要的描述符，防止相符干扰（网络服务器进程常用）。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
